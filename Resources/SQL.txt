
─ │ ═ ║

┌ ┐ └ ┘ ┬ ┴ ├ ┤ ┼

╔ ╗ ╚ ╝ ╦ ╩ ╠ ╣ ╬

╒ ╕ ╘ ╛ ╤ ╧ ╞ ╡ ╪

╓ ╖ ╙ ╜ ╥ ╨ ╟ ╢ ╫

▀ ▄ █ ▌ ▐ ░ ▒ ▓ ■ □ ▪ ▫ ▬ ▲ ► ▼ ◄ ◊ ○ ☺ ☻
██

╔═══════════════════════════════════════════════════════════════════════╗
║
╠═══════════════════════════════════════════════════════════════════════╝
╟─
╟─┐
╟─┬─────────────────────────────────────────────────────────────────────┐
╟─┬─────────────────────────────────────────────────────────────────────┐
	│
	├─┬───────────────────────────────────────────────────────────────────┘
	├─
	├─┐
	├─┬───────────────────────────────────────────────────────────────────┤
	├─┬───────────────────────────────────────────────────────────────────┐
		│
		├───────────────────────────────────────────────────────────────────┘
		├─┬─────────────────────────────────────────────────────────────────┐
			├─┬───────────────────────────────────────────────────────────────┐
				│
				├───────────────────────────────────────────────────────────────┘
				├─┬─────────────────────────────────────────────────────────────┐

╔═══════════════════════════════════════════════════════════════════════╗
║ SQL
╠═══════════════════════════════════════════════════════════════════════╝
SELECT *
FROM table;
* = всичко

SELECT * FROM table ORDER BY column;
подрежда по азбучен ред дадена колона

SELECT column1, column2 FROM table ORDER BY column;
изважда съдържанието само на двете колони

SELECT column1, column2 AS 'column name' FROM table ORDER BY column;
AS задава име на колоната в '' (може да се пропусне)

SELECT COUNT(*) FROM table;
ще върне броя редове
COUNT(*) - функция

SELECT column1, column2 FROM table WHERE column = 'something' LIMIT num;
ще върне редовете които изпълняват условието (израз) column = 'something'
LIMIT 5 първите 5

SELECT COUNT(*) FROM table WHERE column > num AND column = 'sothing';

INSERT INTO table (column1, column2, column3) VALUES ('something', 'something', 'something');

UPDATE table SET column1 = 'something', column2 = 'something' WHERE column = num;

UPDATE table
SET column1 = NULL, column2 = NULL
WHERE column = num;

DELETE FROM table
WHERE column = num;

'-- ' коментар (новред)
/*
	коментар
*/

╟─┬─────────────────────────────────────────────────────────────────────┐
	│expressions
	├─────────────────────────────────────────────────────────────────────┘
	├─┐
		SELECT column1, column2 / num AS 'some name'
			FROM table
			WHERE column >= num
			ORDER BY column DESC;
			
		├─┬─────────────────────────────────────────────────────────────────┐
			column2 / num
			column >= num
			
╟─┬─────────────────────────────────────────────────────────────────────┐
	│CREATE
	├─────────────────────────────────────────────────────────────────────┘
	├─┐
		CREATE DATABASE name;

	
		CREATE TABLE name (
			name1 int NOT NULL PRIMARY KEY,
			name2 nvarchar(255)
		);
		
		INSERT INTO table VALUES (1, 'a');
		INSERT INTO table VALUES (2, 'b');
		INSERT INTO table VALUES (3, 'c');
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│INSERT
	├─────────────────────────────────────────────────────────────────────┘
	├─┐
		INSERT INTO table (
		column1, 
		column2, 
		column3
		) VALUES (
		'something', 
		'something', 
		'something'
		);

╔═══════════════════════════════════════════════════════════════════════╗
║ CodeFirst
╠═══════════════════════════════════════════════════════════════════════╝
╟─ CodeFirst maps your classes to tables using a set of conventions. Classes can be customized using Annotations and the Fluent API. Custom names of objects (columns, tables, etc.) in the DB. Validation and data types. Fix complicated entity relationships.

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Migration
	├─┬───────────────────────────────────────────────────────────────────┘
		enable-migrations
		add-migration <name> -ignorechanges
		update-database –targetmigration: <name>

╟─┬─────────────────────────────────────────────────────────Annotations─┐
	│ Annotations
	├─┬───────────────────────────────────────────────────────────────────┘
		using System.ComponentModel.DataAnnotations;

╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Primary Key
		├───────────────────────────────────────────────────────────────────┘
		├─ Entity Framework look for a property named "Id"/"ID" or one that combines the class name and "Id", such as "BlogId". The property will map to a primary key column in the database.
		
		├─ specify which property is will map to a primary key column
		├─┬─────────────────────────────────────────────────────────────────┐
			public class Blog
			{
				[Key] 
				public int PrimaryTrackingKey { get; set; }
				...
			}
			
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Composite Keys
		├───────────────────────────────────────────────────────────────────┘
		├─ Entity Framework requires you to define an order of the key properties. You can do this using the Column annotation to specify an order.
		├─┬─────────────────────────────────────────────────────────────────┐
			public class Passport
			{
				[Key]
				[Column(Order=1)]
				public int PassportNumber { get; set; }
				
				[Key]
				[Column(Order = 2)]
				public string IssuingCountry { get; set; }
				...
			}
			
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Composite Foreign Keys
		├───────────────────────────────────────────────────────────────────┘
		├─ ???
		├─┬─────────────────────────────────────────────────────────────────┐
			public class PassportStamp
			{
				[Key]
				public int StampId { get; set; }

				[ForeignKey("Passport")]
				[Column(Order = 1)]
				public int PassportNumber { get; set; }

				[ForeignKey("Passport")]
				[Column(Order = 2)]
				public string IssuingCountry { get; set; }
			}
		
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Required
		├───────────────────────────────────────────────────────────────────┘
		├─ Adding Required to the property will force EF (and MVC) to ensure that the property has data in it.
		
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ MaxLength and MinLength
		├─┬─────────────────────────────────────────────────────────────────┘
	    [MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
			public string Name { get; set; }

╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ NotMapped
		├───────────────────────────────────────────────────────────────────┘
		├─ You can mark any properties that do not map to the database with the NotMapped annotation
		
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ ComplexType
		├───────────────────────────────────────────────────────────────────┘
		├─ It’s not uncommon to describe your domain entities across a set of classes to describe a complete entity. For example, you may add a class called BlogDetails to your model.
		├─┬─────────────────────────────────────────────────────────────────┐
			[ComplexType]
			public class BlogDetails
			{
				public DateTime? DateCreated { get; set; }

				[MaxLength(250)]
				public string Description { get; set; }
			}
		├───────────────────────────────────────────────────────────────────┐
		├─ BlogDetails does not have any type of key property. In domain driven design, BlogDetails is referred to as a value object. Entity Framework refers to value objects as complex types.  Complex types cannot be tracked on their own.
		
		├─┬─────────────────────────────────────────────────────────────────┐
			public class Blog
			{
				public BlogDetails BlogDetail { get; set; }
			}
		├───────────────────────────────────────────────────────────────────┐
		├─ As a property in the Blog class, BlogDetails it will be tracked as part of a Blog object. 

╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ ConcurrencyCheck
		├───────────────────────────────────────────────────────────────────┘
		├─ When SaveChanges is called, THE KEY AND THE ORIGINAL VALUE will be used to locate the correct data/cell (by filtering). If someone has changed the the original value in the meantime, this update will fail and you’ll get a DbUpdateConcurrencyException that you'll need to handle.
		
		├─┬─────────────────────────────────────────────────────────────────┐
			[ConcurrencyCheck, MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
			public string BloggerName { get; set; }

╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ TimeStamp
		├───────────────────────────────────────────────────────────────────┘
		├─ Code first will treat Timestamp properties the same as ConcurrencyCheck properties, but it will also ensure that the database field that code first generates is non-nullable. You can only have one timestamp property in a given class. The property type should be a byte array.
		
		├─┬─────────────────────────────────────────────────────────────────┐
			[Timestamp]
			public Byte[] TimeStamp { get; set; }
			
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Table and Column
		├───────────────────────────────────────────────────────────────────┘
		├─ My class is named Blog and by convention, code first presumes this will map to a table named Blogs. If that's not the case you can specify the name of the table with the Table attribute.
		
		├─┬─────────────────────────────────────────────────────────────────┐
			[Table("InternalBlogs")]
			public class Blog
		
		├───────────────────────────────────────────────────────────────────┐
		├─ The Column annotation is a more adept in specifying the attributes of a mapped column. You can stipulate a name, data type or even the order in which a column appears in the table.
		
		├─┬─────────────────────────────────────────────────────────────────┐
			[Column(“BlogDescription", TypeName="ntext")]
			public String Description {get;set;}
			
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ DatabaseGenerated
		├───────────────────────────────────────────────────────────────────┘
		├─ If you're mapping your Code First classes to tables that contain computed columns, you don't want Entity Framework to try to update those columns. But you do want EF to return those values from the database after you've inserted or updated data.
		
		├─┬─────────────────────────────────────────────────────────────────┐
	    [DatabaseGenerated(DatabaseGenerationOption.Computed)]
			public DateTime DateCreated { get; set; }
		
		├───────────────────────────────────────────────────────────────────┐
		├─ You can use database generated on byte or timestamp columns when code first is generating the database, otherwise you should only use this when pointing to existing databases because code first won't be able to determine the formula for the computed column.
		
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ ForeignKey (Relationship Attributes)
		├─┬─────────────────────────────────────────────────────────────────┘
			public class Post
			{
				...
				public int BlogId { get; set; }
				[ForeignKey("BlogId")]
				public Blog Blog { get; set; }
				...
			}
			
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ InverseProperty (Relationship Attributes)
		├───────────────────────────────────────────────────────────────────┘
		├─ The InverseProperty is used when you have multiple relationships between classes.
		
		├───────────────────────────────────────────────────────────────────┐
		├─ In the Post class, you may want to keep track of who wrote a blog post as well as who edited it.
		├─┬─────────────────────────────────────────────────────────────────┐
			public class Post
			{
				...
				public Person CreatedBy { get; set; }
				public Person UpdatedBy { get; set; }
				...
			}
			
		├───────────────────────────────────────────────────────────────────┐
		├─ We also need to add in the Person class referenced by these properties.
		├─┬─────────────────────────────────────────────────────────────────┐
			public class Person
			{
				...
				[InverseProperty("CreatedBy")]
				public List<Post> PostsWritten { get; set; }

				[InverseProperty("UpdatedBy")]
				public List<Post> PostsUpdated { get; set; }
				...
			}
		
╟─├─┬───────────────────────────────────────────────────────Annotations─┐
		│ Custom Annotation
		├─┬─────────────────────────────────────────────────────────────────┘
			[Tag]
		
			public class TagAttribute : ValidationAttribute
			{
				public override bool IsValid(object value)
				{
					string tag = (string)value;
					bool isValid = Regex.IsMatch(tag, @"^#(\w{1,19})(?=[^\s\t]*)$");
					if (!isValid) { return false; }
					return true;
				}
			}
			
		├─┬─────────────────────────────────────────────────────────────────┐
			[CustomMinLength(MinLength = 20)]
			
			public class CustomMinLengthAttribute : ValidationAttribute
			{
				public int MinLength { get; set; }

				public override bool IsValid(object value)
				{
					string tag = (string)value;
					if (tag.Length > this.MinLength) { return false; }
					return true;
					//return base.IsValid(value);
				}
			}

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ DbEntityValidationException
	├─┬───────────────────────────────────────────────────────────────────┘
		try
		{
			context.SaveChanges();
		}
		catch (DbEntityValidationException ex)
		{
			foreach (var eve in ex.EntityValidationErrors)
			{
				Console.WriteLine(
					"Entity of type {0} in state {1} has the following validation errors:",
					eve.Entry.Entity.GetType().Name, // annotation name
					eve.Entry.State);
					
				foreach (var ve in eve.ValidationErrors)
				{
					Console.WriteLine(
						"- Property: {0}, Error: {1}",
						ve.PropertyName, // prop name
						ve.ErrorMessage);
				}
			}
		}
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ DbSet properties with DbContext
	├─────────────────────────────────────────────────────────────────────┘
	├─ The common case shown in Code First examples is to have a DbContext with public automatic DbSet properties for the entity types of your model.
	├─┬───────────────────────────────────────────────────────────────────┐
		public class BloggingContext : DbContext
		{
			public virtual DbSet<Blog> Blogs { get; set; }
			public virtual DbSet<Post> Posts { get; set; }
		}
		├───────────────────────────────────────────────────────────────────┐
		├─ VIRTUAL 
		
╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ IDbSet (mocks or fakes)
		├───────────────────────────────────────────────────────────────────┘
		├─ There are situations, such as when creating mocks or fakes, where it is more useful to declare your set properties using an interface.
		├─┬─────────────────────────────────────────────────────────────────┐
			public class BloggingContext : DbContext
			{
				public IDbSet<Blog> Blogs { get; set; }
				public IDbSet<Post> Posts { get; set; }
			}
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ Read-only Set
		├─┬─────────────────────────────────────────────────────────────────┘
			public class BloggingContext : DbContext
			{
				public DbSet<Blog> Blogs { get {return Set<Blog>();} }
				public DbSet<Post> Posts { get {return Set<Post>();} }
			}

╟─┬───────────────────────────────────────────────────────────FluentAPI─┐
	│ Fluent API
	├─────────────────────────────────────────────────────────────────────┘
	├─ When configuring a relationship with the fluent API, you start with the EntityTypeConfiguration instance and then use the HasRequired, HasOptional, or HasMany method to specify the type of relationship this entity participates in.
	
	├─ We configured all the domain classes using Fluent-API in the OnModelCreating() method. However, it becomes hard to maintain if you configure a large number of domain classes in the OnModelCreating. EF 6 allows you to create a separate class for each entity and place all the configurations related to an entity.
	
╟─├─┬───────────────────────────────────────────────────────────────────┐
		public class StudentConfiguration : EntityTypeConfiguration<Student>
		{
			public StudentConfiguration()
			{
				this.ToTable("StudentInfo");
						
				this.HasKey<int>(s => s.StudentKey);
			}
		}

		public class NameContext: DbContext 
		{
			public NameContext(): base() {}

			public virtual DbSet<Student> Students { get; set; }
			
			protected override void OnModelCreating(DbModelBuilder modelBuilder)
			{
				// Moved all Student related configuration to StudentConfiguration class
				
				modelBuilder.Configurations.Add(new StudentConfiguration());
			}
		}
╟─├─┬─────────────────────────────────────────────────────────FluentAPI─┐
		│ One-to–Zero or One (Required-to-Optional)
		├───────────────────────────────────────────────────────────────────┘
		├─ Configure the primary key for the OfficeAssignment
		├─┬─────────────────────────────────────────────────────────────────┐
			modelBuilder.Entity<OfficeAssignment>()
				.HasKey(t => t.InstructorID);

		├─ Map one-to-zero or one relationship
		├─┬─────────────────────────────────────────────────────────────────┐
			modelBuilder.Entity<OfficeAssignment>()
				.HasRequired(t => t.Instructor)
				.WithOptional(t => t.OfficeAssignment);
				
╟─├─┬─────────────────────────────────────────────────────────FluentAPI─┐
		│ One-to–One (Both Ends Are Required)
		├───────────────────────────────────────────────────────────────────┘
		├─ Configure the primary key for the OfficeAssignment
		├─┬─────────────────────────────────────────────────────────────────┐
			modelBuilder.Entity<OfficeAssignment>()
				.HasKey(t => t.InstructorID);

			modelBuilder.Entity<Instructor>()
				.HasRequired(t => t.OfficeAssignment)
				.WithRequiredPrincipal(t => t.Instructor);
				
╟─├─┬─────────────────────────────────────────────────────────FluentAPI─┐
		│ Many-to-Many
		├─┬─────────────────────────────────────────────────────────────────┘
			modelBuilder.Entity<Course>()
				.HasMany(t => t.Instructors)
				.WithMany(t => t.Courses)
			├─────────────────────────────────────────────────────────────────┘
			├─ As a result the CourseInstructor table is created with Course_CourseID and Instructor_InstructorID columns.
			
		├─┬─────────────────────────────────────────────────────────────────┐
			modelBuilder.Entity<Course>()
				.HasMany(t => t.Instructors)
				.WithMany(t => t.Courses)
				.Map(m =>
				{
						m.ToTable("CourseInstructor");
						m.MapLeftKey("CourseID");
						m.MapRightKey("InstructorID");
				});
			├─────────────────────────────────────────────────────────────────┘
			├─ f you want to specify the join table name and the names of the columns in the table you need to do additional configuration by using the Map method.
			
╟─├─┬─────────────────────────────────────────────────────────FluentAPI─┐
		│ Many-to-Many Custom TABLE WITH ADDITIONAL PROP 
		├───────────────────────────────────────────────────────────────────┘
		├─ It s not possible to create a many-to-many relationship with a customized join table. To work with such a join table with additional properties you will have to create actually two one-to-many relationships.
		
		├─ Relationships
		├─┬─────────────────────────────────────────────────────────────────┐
			builder.Entity<User>()
				.HasKey(q => q.UserID);
				
			builder.Entity<Email>()
				.HasKey(q => q.EmailID);
				
			builder.Entity<UserEmail>()
				.HasKey(q => new { 
						q.UserID, q.EmailID
				});

			builder.Entity<UserEmail>()
				.HasRequired(t => t.Email)
				.WithMany(t => t.UserEmails)
				.HasForeignKey(t => t.EmailID)

			builder.Entity<UserEmail>()
				.HasRequired(t => t.User)
				.WithMany(t => t.UserEmails)
				.HasForeignKey(t => t.UserID)
				
		├─ Models
		├─┬─────────────────────────────────────────────────────────────────┐
			public class User {
				public int UserID { get; set; }
				public string Username { get; set; }
				public string Password { get; set; }

				public ICollection<UserEmail> UserEmails { get; set; }
			}

			public class Email {
				public int EmailID { get; set; }
				public string Address { get; set; }

				public ICollection<UserEmail> UserEmails { get; set; }
			}

			public class UserEmail {
				public int UserID { get; set; }
				public User User { get; set; }
				
				public int EmailID { get; set; }
				public Email Email { get; set; }
				
				public bool IsPrimary { get; set; }
			}
				
╟─├─┬─────────────────────────────────────────────────────────FluentAPI─┐
		│ One Navigation Property
		├─┬─────────────────────────────────────────────────────────────────┘
			
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ unique index
		├─┬─────────────────────────────────────────────────────────────────┘
			using System.Data.Entity.ModelConfiguration;
			using System.Data.Entity.Infrastructure.Annotations;
			using System.ComponentModel.DataAnnotations.Schema;
			
			public class ModelNameConfig : EntityTypeConfiguration<ModelName>
			{
				modelBuilder.Entity<ModelName>() 
					.Property(m => m.PropName)
					.HasColumnAnnotation(
						IndexAnnotation.AnnotationName, 
						new IndexAnnotation(
							new IndexAttribute("IX_ModelName_PropName", 1) { IsUnique = true }));
			}
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ ooo (Model Builder)
		├─┬─────────────────────────────────────────────────────────────────┘
			using System.Data.Entity.ModelConfiguration;
			
			public class UserConfig
				: EntityTypeConfiguration<User>
			{
				public UserConfig()
				{
					// тази връзка е едностранна
					// userA има приятел userB но той нама приятел userA
					this.HasMany(u => u.Friends)
						.WithMany();
						.Map(u =>
						{
							u.ToTable("Friends");
							u.MapLeftKey("UserId");
							u.MapRightKey("FriendId");
						});
				}
			}

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Executing Native SQL Queries
	├─────────────────────────────────────────────────────────────────────┘
	├─ context.Database.SqlQuery<return-type>(native-SQL-query);
	├─┬───────────────────────────────────────────────────────────────────┐
		var context = new SoftUniEntities();
		string query = @"
		SELECT COUNT(*) FROM dbo.Employees
		";
		var queryResult = context.Database.SqlQuery<int>(query);
		int count = queryResult.FirstOrDefault();
		
	├─┬───────────────────────────────────────────────────────────────────┐
		string query = @"
		SELECT FirstName + " " + LastName
		FROM dbo.Employees
		WHERE JobTitle = {0}
		";
		var employees = context.Database
			.SqlQuery<string>(query, "Marketing Specialist");
			
		foreach (var emp in employees) { Console.WriteLine(emp); }
		
	├─┬───────────────────────────────────────────────────────────────────┐
		string query = @"
		SELECT FirstName + " " + LastName
		FROM dbo.Employees
		WHERE JobTitle = @parameterName
		";
		var parameterName = new SqlParameter("@parameterName", "Marketing Specialist");
		var employees = context.Database.SqlQuery<string>(query);
		
		foreach (var emp in employees) { Console.WriteLine(emp); }
		
		
	├─ context.Database
	.ExecuteSqlCommand(File.ReadAllText("../../file-name.sql"));
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Attaching and Detaching Objects
	├─────────────────────────────────────────────────────────────────────┘
	├─ In Entity Framework, objects can be attached to the object context (tracked object) or detached from an object context (untracked object)
	├─ Attached objects are tracked and managed by the DbContext. SaveChanges() persists all changes in DB.
	├─ Detached objects are not referenced by the DbContext. Behave like a normal objects, which are not related to EF.
	├─ When a query is executed inside an DbContext, the returned objects are automatically attached to it. When a context is destroyed, all objects in it are automatically detached.
	
	├─██ You might later on attach to a new context objects that have been previously detached.


	├─┬───────────────────────────────────────────────────────────────────┐
		Employee GetEmployeeById(int id)
		{
			 using (var context = new SoftUniContext())
			 {
					return context.Employees
						 .First(p => p.EmployeeID == id);
			 }
		}
		├───────────────────────────────────────────────────────────────────┘
		├─██ когато using(){} приключи context изчезва и всички entity-та на тази инстанция стават detached
		
		├─┬─────────────────────────────────────────────────────────────────┐
			static void Main()
			{
					var context1 = new SoftUniContext();
					var employee = LoadAndDetach();
					
					Console.WriteLine(context1.Entry(employee).State);
					// Detached
					
					context1.Entry(employee).State = System.Data.Entity.EntityState.Modified;
					// това го attach-ва към context1 и Modified ни позволява да го променяме
					// context1.Employees.Attach(employee);
					context.SaveChanges();
					
			}

			static Employee LoadAndDetach()
			{
					using (var context2 = new SoftUniContext())
					{
							var employee = context2.Employees.FirstOrDefault();
							return employee;
					}
			}
			
		├─┬─────────────────────────────────────────────────────────────────┐
			void UpdateName(Employee employee, string newName)
			{
				 using (var softUniEntities = new SoftUniEntities())
				 {
						var entry = softUniEntities.Entry(employee);
						entry.State = EntityState.Added;
						employee.FirstName = newName;
						softUniEntities.SaveChanges();
				 } 
			}
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	│EntityFramework.Extended
	├─────────────────────────────────────────────────────────────────────┘
	├─ Install-Package EntityFramework.Extended
	├─ Multiple Update and Delete in Single Query. EF.Extended gives you the ability to perform bulk deletion of rows/entities by given criteria.
	
	├─┬───────────────────────────────────────────────────────────────────┐
		context.Users.Delete(u => u.FirstName == "Pesho");
		context.Employees.Update(
			t => t.Name == "Nasko",
			t => new Employee() {Name = "Plamen"}
		);
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Update all Employees with Name "Nasko" to "Plamen"

	├─┬───────────────────────────────────────────────────────────────────┐
		IQueryable<Employee> employees = context.Employees
			.Where(e => e.Name == "Plamen");
		context.Employees.Update(
			employee, e => new Employee() { Age = 99; }
		);
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Update all Employees Age to 99 who have a name "Plamen"
			
╟─┬─────────────────────────────────────────────────────────────────────┐
	│Stored Procedures
	├─────────────────────────────────────────────────────────────────────┘
	├─┐
		CREATE PROCEDURE UpdateAge @param int
		AS BEGIN
		UPDATE Employees
		SET Age = Age + @param;
		END
		└─┬─────────────────────────────────────────────────────────────────┘
			SqlParameter param = new SqlParameter("@age", SqlDbType.Int);
			param.Value = 2;
			context.Database.ExecuteSqlCommand(
				"UpdateAge @age", param
			);

╟─┬─────────────────────────────────────────────────────────────────────┐
	│Concurrency Control in EF
	├─────────────────────────────────────────────────────────────────────┘
	├─ EF runs in optimistic concurrency mode (no locking). By default the conflict resolution strategy in EF is "last wins". The last change overwrites all previous concurrent changes.
	├─ Enabling "first wins" strategy for certain property in EF
	└─┬───────────────────────────────────────────────────────────────────┘
		oncurrencyMode=Fixed // in DBfirst project

╔═══════════════════════════════════════════════════════════════════════╗
║ Project Organization
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Application code can be split into sections. Create separate projects for each layer of your app.
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Data Layer – database connection.
	└─┬───────────────────────────────────────────────────────────────────┘
		├─ Class library with "ProjectName.Data".
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Add a new ADO.NET item from the context menu.
			├─ Add a reference to the "ProjectName.Models".
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Domain Models – entity classes.
	└─┬───────────────────────────────────────────────────────────────────┘
		├─ Class library with "ProjectName.Models".
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Model size affects query performance
			├─ Split model to only serve the operation performed – don't initialize entire database.
			├─ Always include foreign key property along with navigation properties
			├─ using System.ComponentModel.DataAnnotations; requires EF 

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Client – user-interaction and app logic
	└─┬───────────────────────────────────────────────────────────────────┘
		├─ Console, WPF, ASP.NET, etc. (your choice) with "ProjectName.Client".
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Add a reference to the "ProjectName.Models" and "ProjectName.Data".
			├─ Copy and replace App.config from ProjectName.Data
			├─ Copy EntityFramework.SqlServer.dll from ProjectName.Data/bin/debug after running if once to populate folder debug (or mmm ... Install Entity Framework from the NuGet Package Manager)


╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Service
	└─┬───────────────────────────────────────────────────────────────────┘
		├─ Class library with "ProjectName.Service".
		└─┬─────────────────────────────────────────────────────────────────┘
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Business Logic (optional) – data validation, transformations
	└─────────────────────────────────────────────────────────────────────┘

╟─ Reasons
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Easier to locate files when maintaining
	├─────────────────────────────────────────────────────────────────────┤
	│ Don't have to rebuild entire codebase after changes (DLLs)
	└─────────────────────────────────────────────────────────────────────┘
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Optimization
	└─┬───────────────────────────────────────────────────────────────────┘
		├─ LINQ queries 
		└─┬────────────────────────────────────────────────────────────LINQ─┘
			├─ LINQ queries are executed each time the data is accessed. Try to delay execution (materialization) until you actually need the results.
			└─┬───────────────────────────────────────────────────────────────┤
				├─ ToList() ... , Count(), Average(), First()
				├─ When a property is accessed
				
╟─├─├─┬─────────────────────────────────────────────────────────────────┐
			├─ Execute your query before using it in a loop
			├─────────────────────────────────────────────────────────────────┤
			├─ Monitor query execution using Express Profiler
			└─┬───────────────────────────────────────────────────────────────┘
				Console.WriteLine(context.Employees); // ще покаже sql заявка
				
╟─├─├─┬─────────────────────────────────────────────────────────────────┐
			├─ Only fetch required data by filtering and projecting your queries.
			└─┬───────────────────────────────────────────────────────────────┘
				.Where(e => e ...)
				.Select(e => new { e... , e... , ...});
				// new {} е анонимен обект затова неможе да го променяме

╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ EF will cache queries and compare for changes
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Disable change detection
			└─┬───────────────────────────────────────────────────────────────┘
				try {
						context.Configuration.AutoDetectChangesEnabled = false;
						var product = context.Products.Find(productId);
						...
				// } catch() {
				} finally {
						context.Configuration.AutoDetectChangesEnabled = true;
				}
				
╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ When adding or updating a record, EF call DetectChanges().
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Use AddRange() and RemoveRange() to reduce calls.
			└─┬───────────────────────────────────────────────────────────────┘
				List<Product> products = new List<Product>()
					{ product1, product2, product3 };
				context.Products.AddRange(products);
				
			├─┬───────────────────────────────────────────────────────────────┘
				context.Products.AddRange(new Product[] {...});

╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ EF tracks every loaded entity. If we only want to display data, this process is redundant.
		└─┬─────────────────────────────────────────────────────────────────┘
			├─ Disable tracking
			└─┬───────────────────────────────────────────────────────────────┘
				context.Products
					.AsNoTracking()
					.Where(p => p...)
					.ToList();

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Loading Methods
	└─┬───────────────────────────────────────────────────────────────────┘
		├─██ Do you need to access many navigation properties from the fetched entities?
		└─┬─────────────────────────────────────────────────────────────────┘
			│No ├─ Lazy for large payloads
			│		├─ Eager for small payloads
			├─────────────────────────────────────────────────────────────────┤
			│Yes├─ Eager loading for up three entities
			│   ├─ Lazy for more
			└─────────────────────────────────────────────────────────────────┘
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─██ Do you know exactly what data will be needed at run time?
		└─┬─────────────────────────────────────────────────────────────────┘
			│No ├─ Lazy
			├─────────────────────────────────────────────────────────────────┤
			│Yes├─ Eager at first
			│   ├─ Lazy if loading lots of data
			└─────────────────────────────────────────────────────────────────┘
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─██ Is your code executing far from your database? (network latency). Don’t take database proximity for granted.
		└─┬─────────────────────────────────────────────────────────────────┘
			│No ├─ Lazy will simplify your code
			├─────────────────────────────────────────────────────────────────┤
			│Yes├─ Depending on scenario
			│   ├─ Eager will require fewer round trips
			└─────────────────────────────────────────────────────────────────┘
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─ Eager Loading (less queries)
		├───────────────────────────────────────────────────────────────────┘
		├─ Eager loading is the process whereby a query for one type of entity also loads related entities as part of the query. Eager loading is achieved by the use of the Include method.
		└─┬─────────────────────────────────────────────────────────────────┘
			context.Towns.Include(town => town.Employees);
			└─┬───────────────────────────────────────────────────────────────┘
				├─ The Include is found in the System.Data.Entity

╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─ Lazy Loading (more queries)
		├───────────────────────────────────────────────────────────────────┘
		├─ Active by default, can be turned off via configuration
		└─┬─────────────────────────────────────────────────────────────────┘
			public CompanyContext()
				: base("name=CompanyContext")
			{ Configuration.LazyLoadingEnabled = false; }

╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─ Explicit Loading
		└─┬─────────────────────────────────────────────────────────────────┘
			var person = context.People.FirstOrDefault();
			context.Entry<>(person)
       .Collection(b => b.Posts)
       .Query()
       .Where(p => p.Tags.Contains("entity-framework")
       .Load();
			 
╟─├─├─┬─────────────────────────────────────────────────────────────────┐
			├─ Local cache can be accessed without sending a query
			└─┬───────────────────────────────────────────────────────────────┘
				var localPosts = context.Posts.Local; 
				localPosts.Add(new Post { Name = "What's New in EF" }); 
				localPosts.Remove(context.Posts.Find(1));
				
				
				
╔═══════════════════════════════════════════════════════════════════════╗
║ LINQ
╠═══════════════════════════════════════════════════════════════════════╝

contex.Users.SingleOrDefault(u => u.FirstName == name);
Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.What is the difference between Single and SingleOrDefault? The difference is what happens when zero matching elements are found. With Single, an exception is thrown in this case. But with SingleOrDefault, the default value is returned. 

contex.Users.Any(u => u.Username == username);


╔═══════════════════════════════════════════════════════════════════════╗
║ AutoMapper
╠═══════════════════════════════════════════════════════════════════════╝

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Data Transfer Object DTO
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Storage of values, object that carries data between the server and client
		├─┬─────────────────────────────────────────────────────────────────┘		
			public class NameDTO
			{
				prop { get; set; }
				prop { get; set; }
			}

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Add mappings
	├─┬───────────────────────────────────────────────────────────────────┘
		using AutoMapper;
		
		Mapper.Initialize(cfg =>
			cfg.CreateMap<NameSource, NameDTO>());
			
		var nameProp = context.NameSources.FirstOrDefault();
		
		NameDTO dto = Mapper.Map<NameDTO>(nameProp);
		
╟─├─┬───────────────────────────────────────────────────────────────────┘
		Mapper.Initialize(cfg => 
		{
			cfg.CreateMap<NameSource1, Name1DTO>();
			cfg.CreateMap<NameSource2, Name2DTO>();
			...;
		});

╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ Map properties that don't match naming convention
		├─┬─────────────────────────────────────────────────────────────────┘
			Mapper.Initialize(cfg =>
				cfg.CreateMap<NameSource, NameDTO>()
					 .ForMember(dto => dto.propNameDTO,
											opt => opt.MapFrom(src => 
												src.propNameSource.Sum(p => p.Something))));
			├─┬───────────────────────────────────────────────────────────────┘
				Mapper.Initialize(=>
					.CreateMap<,>()
						.ForMember(
							=>.prop,
							=>.MapFrom(=>.prop.Sum(=>.prop))));

╟─├─┬───────────────────────────────────────────────────────────────────┐
		│ Collection Mapping
		├─┬─────────────────────────────────────────────────────────────────┘
			List<NameDTO> nameDTOs = Mapper.Map<NameProp[],List<NameDTO>>(nameListProp);
			
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ LINQ query using ProjectTo()
	├─┬───────────────────────────────────────────────────────────────────┘
		using AutoMapper.QueryableExtensions;
		
		context.Products
			.Where(p => p.Id == 18)
			.ProjectTo<ProductDTO>()
			.ToList();

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Conditional mapping
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ AutoMapper allows you to add conditions to properties that must be met before that property will be mapped.
		
	├─┬───────────────────────────────────────────────────────────────────┘
		class Foo { int baz; }
		class Bar { uint baz; }
		
		Mapper.Initialize(cfg =>
		{
			cfg.CreateMap<Foo,Bar>()
				.ForMember(
					dest => dest.baz,
					opt => opt.Condition(src => (src.baz >= 0))); 
		});

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Configuration validation
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ AutoMapper provides configuration testing in the form of the AssertConfigurationIsValid method.
		
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Mapper.Configuration.AssertConfigurationIsValid();
		├─┬─────────────────────────────────────────────────────────────────┘
			├─ AutoMapper checks to make sure that every single Destination type member has a corresponding type member on the source type.

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Custom type converters
	├─┬───────────────────────────────────────────────────────────────────┘

    public class Source
    {
        public string Value1 { get; set; }
        public string Value2 { get; set; }
    }
				
    public class Destination
    {
        public int Value1 { get; set; }
        public DateTime Value2 { get; set; }
    }
				
    public void Example()
    {
        Mapper.Initialize(cfg => {
          cfg.CreateMap<string, int>()
						//.ConvertUsing(Convert.ToInt32);
						.ConvertUsing(x => int.Parse(x));
						
          cfg.CreateMap<string, DateTime>()
						//.ConvertUsing(new DateTimeTypeConverter());
						.ConvertUsing(x => Convert.ToDateTime(x));
						
          cfg.CreateMap<Source, Destination>();
        });
				
        Mapper.AssertConfigurationIsValid();

        var source = new Source
        {
            Value1 = "5",
            Value2 = "01/01/2000",
        };

        Destination result = Mapper.Map<Source, Destination>(source);

    }

    public class DateTimeTypeConverter : ITypeConverter<string, DateTime>
    {
        public DateTime Convert(
				string source, 
				DateTime destination, 
				ResolutionContext context)
        {
            return System.Convert.ToDateTime(source);
        }
    }

╔═════════════════════════════════════════════════════════════════════════╗
║ JSON Serializers (dont use)
╠═════════════════════════════════════════════════════════════════════════╝




╟─ Add Reference -> Framework -> System.Web.Extensions
╟─┬───────────────────────────────────────────────────────────────────────┐
	│ JavaScriptSerializer
	├─┬─────────────────────────────────────────────────────────────────────┘
		var name = new Product();
		var serializer = new JavaScriptSerializer();
		
		var jsonProduct = serializer.Serialize(name);
		var objProduct = serializer.Deserialize<Product>(jsonProduct);

		var products = new Dictionary<string, Product>
		{
			{ "pump", firstProduct },
			{ "filter", secondProduct }
		};
		
		var jsonProducts = serializer.Serialize(products);
		var objProducts = serializer
			.Deserialize<Dictionary<string, Product>>(jsonProducts);

╔═══════════════════════════════════════════════════════════════════════╗
║ JSON.NET
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Install-Package Newtonsoft.Json
╟─┬─────────────────────────────────────────────────────────────────────┘
	using Newtonsoft.Json;
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ JSON.NET exposes a static service JsonConvert
	├─┬───────────────────────────────────────────────────────────────────┘
		var products = Mapper.Map<List<ProductDto>>(context.Products.ToList())
	
		var jsonProducts = JsonConvert.SerializeObject(products);
		
		var objProduct = JsonConvert.DeserializeObject<Product>(jsonProduct);

╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ To indent the output string use Formatting.Indented
	├─┬───────────────────────────────────────────────────────────────────┘
		JsonConvert.SerializeObject(products, Formatting.Indented);

╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ Deserializing to anonymous types
	├─┬───────────────────────────────────────────────────────────────────┘
		var template = new 
		{
			FirstName = string.Empty,
			LastName = string.Empty,
			Occupation = string.Empty
		};

		var json = @"{ 
			'firstName': 'Vladimir',
			'lastName': 'Georgiev',
			'jobTitle': 'Technical Trainer' }";

		var person = JsonConvert
			.DeserializeAnonymousType(json, template);

╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ JSON.NET Attributes
	├─┬───────────────────────────────────────────────────────────────────┘
		public class User
		{
			[JsonProperty("user")]
			public string Username { get; set; }
			[JsonIgnore]
			public string Password { get; set; }
		}

╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ LINQ-to-JSON
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Create from JSON string
		├─┬─────────────────────────────────────────────────────────────────┘
			JObject obj = JObject.Parse(jsonProduct);
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─ Read file into a string and deserialize JSON to a type
		├─┬─────────────────────────────────────────────────────────────────┘
			var usersJson = File.ReadAllText(
				@"../../FolderName/users.json");
			
			var users = JsonConvert
				.DeserializeObject<List<User>>(usersJson);
			
╟─├─┬───────────────────────────────────────────────────────────────────┐
		├─ Deserialize JSON directly from a file
		├─┬─────────────────────────────────────────────────────────────────┘
			using (StreamReader file = File.OpenText(
				@"../../FolderName/users.json"))
			{
				 var serializer = new JsonSerializer();
				 User movie2 = (User)serializer.Deserialize(file, typeof(User));
			}

╟─├─├───────────────────────────────────────────────────────────────────┐
		var json = @"{
		'products': [
			{
				'name': 'Fruits', 
				'products': ['apple', 'banana', 'orange']
			},
			{
				'name': 'Vegetables', 
				'products': ['cucumber', 'potato', 'eggplant']
			}]
		}";
		
		JObject obj = JObject.Parse(json);
		
		int index = 1;

		List<string> products = obj["products"]
			.Select(c => string.Format("{0}. {1} ({2})",
				index++, c["name"], string.Join(", ", c["products"])))
			.toList();

╟─├─├───────────────────────────────────────────────────────────────────┐
		├ JArray
		├───────────────────────────────────────────────────────────────────┘		
		JArray arr = JArray.Parse(File.ReadAllText(filePath));
		foreach (JObject obj in arr)
		{
			Console.WriteLine(obj["some"].ToString());
		}
		
╟─├─├───────────────────────────────────────────────────────────────────┐
		├ JsonTextReader
		├───────────────────────────────────────────────────────────────────┘	
		JsonTextReader reader = new JsonTextReader(File.OpenText(coursesPath));
		while (reader.Read())
		{
			if (reader.Value != null)
			{
				Console.WriteLine(string.Format("Token: {0}, Value: {1}", reader.TokenType, reader.Value));
			}
			else
			{
				Console.WriteLine(string.Format("Token: {0}", reader.TokenType));
			}
		}
╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ Circular reference detected
	├─┬───────────────────────────────────────────────────────────────────┘


JsonSerializerSettings settings = new JsonSerializerSettings
{
	//1 -> ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
	//2 -> PreserveReferencesHandling = PreserveReferencesHandling.Objects,
	//3 -> PreserveReferencesHandling = PreserveReferencesHandling.All,
	Formatting = Formatting.Indented
};

var users = JsonConvert
	.DeserializeObject<List<User>>(usersJson, settings);


╔═══════════════════════════════════════════════════════════════════════╗
║ XML
╠═══════════════════════════════════════════════════════════════════════╝
╟─┬─────────────────────────────────────────────────────────────────────┐
	├─ Load XML directly from file
	├─┬───────────────────────────────────────────────────────────────────┘
		using System.Xml.Linq;
		
		XDocument xmlDoc = XDocument.Load(strPath);

		
user.Attribute("first-name").Value
(string)user.Attribute("first-name")
That uses the explicit conversion from XElement to string, which handles a null input by returning a null output. The same is true for all explicit conversions on XAttribute and XElement to nullable types, including nullable value types such as int? - you just need to be careful if you're using nested elements. 

























































password.Any(c => char.IsDigit(c))
password.Any(char.IsDigit)

Include("TableName") ako nesme slogili virtual

string под defoult е nullable


Image -> using System.Drawing -> Add Reference -> Assemblies -> Framework

Newtonsoft Json CheckForCircularReference

Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.CheckForCircularReference(JsonWriter writer, Object value, JsonProperty property, JsonContract
contract, JsonContainerContract containerContract, JsonProperty containerPropert


╔═══════════════════════════════════════════════════════════════════════╗
║
╠═══════════════════════════════════════════════════════════════════════╝
╟─
╟─┐
╟─┬─────────────────────────────────────────────────────────────────────┐
╟─┬─────────────────────────────────────────────────────────────────────┐
	│
	├─────────────────────────────────────────────────────────────────────┘
	├─
	├─┐
	├─┬───────────────────────────────────────────────────────────────────┐
	├─┬───────────────────────────────────────────────────────────────────┐
		│
		├───────────────────────────────────────────────────────────────────┘
		├─┬─────────────────────────────────────────────────────────────────┐
			├─┬───────────────────────────────────────────────────────────────┐
				│
				├───────────────────────────────────────────────────────────────┘
				├─┬─────────────────────────────────────────────────────────────┐