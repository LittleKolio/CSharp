╔═══════════════════════════════════════════════════════════════════════╗
║ Sets (Хеш-таблици)
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Реализацията с хеш-таблица има важното предимство, че времето за достъп до стойност от речника, при правилно използване, теоретично не зависи от броя на елементите в него.

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Random Access
	├─┬───────────────────────────────────────────────────────────────────┘
    ├─ Когато реализациите на някои структури от данни ни дават време за достъп до елементите й, независещ от броя на елементите в нея, се казва, че те притежават свойството random access (свободен достъп).

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ HashSet<T>
	├─┬───────────────────────────────────────────────────────────────────┘
		IntersectWith()
		ExceptWith()
		UnionWith()


╔═══════════════════════════════════════════════════════════════════════╗
║ Dictionary (асоциативни масиви или карти)
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Речниците са известни още като асоциативни масиви (associative arrays) или карти (maps). Тук ще използваме термина "речник". Всяко едно от различните имена подчертава една и съща характеристика на тази структура от данни, а именно, че в тях всеки елемент представлява съответствие между ключ и стойност – наредена двойка.

╟─ При структурата речник, ключът може да не е просто номерче, а всякакъв друг обект. В случая, когато имаме ключ (номер), можем да реализираме такава структура като обикновен масив. Тогава множеството от ключове е предварително ясно – числата от 0 до n, където n е размерът на масива (естествено при разумно ограничение на n).

╟─██ Целта на речниците е да ни освободи, до колкото е възможно, от ограниченията за множеството на ключовете.

╟─ В .NET има две основни имплементации на интерфейса IDictionary<K, V>: Dictionary<K, V> и SortedDictionary<K, V>. SortedDictionary представлява имплементация с балансирано (червено-черно) дърво, а Dictionary – имплементация с хеш-таблица.


╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Case Insensitive
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ tell the dictionary instance to use the standard string compare method (which is case sensitive) a case insensitive one. This is done using the appropriate constructor:
		
		Dictionary<string,YourClass> dic = new Dictionary<string,YourClass>(StringComparer.OrdinalIgnoreCase);
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ SortedDictionary
	├─┬───────────────────────────────────────────────────────────────────┘

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Print Dictionry<str, Dictionary<str, int>>
	├─┬───────────────────────────────────────────────────────────────────┘
		foreach (var user in users.OrderBy(e => e.Key))
		{
			Console.WriteLine($"{user.Key}: ");
			Console.WriteLine("{0}.", 
				string.Join(", ", user.Value.Select(
					e => $"{e.Key} => {e.Value}")));
		}

		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Get first element
	├─┬───────────────────────────────────────────────────────────────────┘
    ├─ Note that to call First here is actually to call a Linq extension of IEnumerable, which is implemented by Dictionary<TKey,TValue>. But for a Dictionary, "first" doesn't have a defined meaning. The last item added ends up being the "First" (in other words, it behaves like a Stack), but that is implementation specific, it's not the guaranteed behavior. In other words, using it should be treated as akin to getting a random item from the Dictionary.
		
╟─├─┬───────────────────────────────────────────────────────────────────┐
    ├─ You could derive a specific meaning from the use of First by combining it with the Linq OrderBy
		├─┬─────────────────────────────────────────────────────────────────┘
      var first = dic.OrderBy(kvp => kvp.Key).First();
























─ │ ═ ║

┌ ┐ └ ┘ ┬ ┴ ├ ┤ ┼

╔ ╗ ╚ ╝ ╦ ╩ ╠ ╣ ╬

╒ ╕ ╘ ╛ ╤ ╧ ╞ ╡ ╪

╓ ╖ ╙ ╜ ╥ ╨ ╟ ╢ ╫

▀ ▄ █ ▌ ▐ ░ ▒ ▓ ■ □ ▪ ▫ ▬ ▲ ► ▼ ◄ ◊ ○ ☺ ☻
██

╔═══════════════════════════════════════════════════════════════════════╗
║
╠═══════════════════════════════════════════════════════════════════════╝
╟─
╟─┐
╟─┬─────────────────────────────────────────────────────────────────────┐
╟─┬─────────────────────────────────────────────────────────────────────┐
	│
	├─────────────────────────────────────────────────────────────────────┘
	├─
	├─┐
	├─┬───────────────────────────────────────────────────────────────────┐
	├─┬───────────────────────────────────────────────────────────────────┐
		│
		├───────────────────────────────────────────────────────────────────┘
		├─┬─────────────────────────────────────────────────────────────────┐
			├─┬───────────────────────────────────────────────────────────────┐
				│
				├───────────────────────────────────────────────────────────────┘
				├─┬─────────────────────────────────────────────────────────────┐