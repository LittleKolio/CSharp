╔═══════════════════════════════════════════════════════════════════════╗
║ List (Списък)
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Списък е линейна структура от данни, която съдържа поредица от
елементи.

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Статичен списък (реализация чрез масив)
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ недостатък – операциите добавяне и премахване от вътрешността на списъка изискват пренареждане на елементите (преоразмеряване на масива).
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Свързан списък (динамична реализация)
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ При често добавяне и премахване (особено при голям брой елементи) се използват т. нар. свързани списъци. Докато при статичния списък всеки от елементите съдържа само конкретния обект, при динамичния списък всеки от елементите пази информация за следващия елемент.
		
	├─┬───────────────────────────────────────────────────────────────────┐
		public class DynamicList
		{
			private class Node
			{
				private object element;
				private Node next;
				
				public object Element
				{
					get { return element; }
					set { element = value; }
				}
				
				public Node Next
				{
					get { return next; }
					set { next = value; }
				}
				
				public Node(object element, Node prevNode)
				{
					this.element = element;
					prevNode.next = this;
				}
				
				public Node(object element)
				{
					this.element = element;
					next = null;
				}
			}
			
			private Node head;
			private Node tail;
			private int count;
			
			/*...*/
			
			public DynamicList()
			{
				this.head = null;
				this.tail = null;
				this.count = 0;
			}
			
			public void Add(object item) {}
			public object RemoveAt(int index) {}
			public int Remove(object item) {}
			public int IndexOf(object item) {}
			public object this[int index] {}
			public int Count {get { return count; }}
		}
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ ArrayList
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Един от основните проблеми при статичната реализация на списък е преоразмеряването на вътрешния масив при добавянето и премахването на елементи. В класа ArrayList проблемът е решен чрез предварително създаване на по-голям масив, който ни предоставя възможност да добавяме елементи, без да преоразмеряваме масива при всяко добавяне или премахване на елементи.
	
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ List<T>
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Класът List се представя в паметта като масив, от който една част съхранява елементите му, а останалите са свободни и се пазят като резервни.
		
	├─┬───────────────────────────────────────────────────────────────────┐
		│ Кога да използваме List<T>
		├─┬─────────────────────────────────────────────────────────────────┘
			├─ Търсенето по индекс става много бързо – можем да достъпваме с еднаква скорост всеки един от елементите независимо от общия им брой.
		
			├─ Търсенето по стойност на елемент работи с толкова сравнения, колкото са елементите (в най-лошия случай), т.е. не е бързо.
			
			├─ Добавянето и премахването на елементи е бавна операция – когато добавяме или премахваме елементи, особено, ако те не се намират в края на списъка, се налага да разместваме всички останали елементи, а това е много бавна операция.
			
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ LinkedList<T>
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ Елементите му пазят информация за обекта, който съхраняват, и указател към следващия и предишния елемент.
		
		├─ Търсенето на елемент по индекс или по съдържание в LinkedList е бавна операция, тъй като се налага да обхождаме всички елементи последователно като започнем от началото на списъка.
		
		├─ Изтриването на елемент е бавна операция, защото включва търсене.
		
╔═══════════════════════════════════════════════════════════════════════╗
║ Sets (Хеш-таблици)
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Реализацията с хеш-таблица има важното предимство, че времето за достъп до стойност от речника, при правилно използване, теоретично не зависи от броя на елементите в него.

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Random Access
	├─┬───────────────────────────────────────────────────────────────────┘
    ├─ Когато реализациите на някои структури от данни ни дават време за достъп до елементите й, независещ от броя на елементите в нея, се казва, че те притежават свойството random access (свободен достъп).

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ HashSet<T>
	├─┬───────────────────────────────────────────────────────────────────┘
		IntersectWith()
		ExceptWith()
		UnionWith()


╔═══════════════════════════════════════════════════════════════════════╗
║ Dictionary (асоциативни масиви или карти)
╠═══════════════════════════════════════════════════════════════════════╝
╟─ Речниците са известни още като асоциативни масиви (associative arrays) или карти (maps). Тук ще използваме термина "речник". Всяко едно от различните имена подчертава една и съща характеристика на тази структура от данни, а именно, че в тях всеки елемент представлява съответствие между ключ и стойност – наредена двойка.

╟─ При структурата речник, ключът може да не е просто номерче, а всякакъв друг обект. В случая, когато имаме ключ (номер), можем да реализираме такава структура като обикновен масив. Тогава множеството от ключове е предварително ясно – числата от 0 до n, където n е размерът на масива (естествено при разумно ограничение на n).

╟─██ Целта на речниците е да ни освободи, до колкото е възможно, от ограниченията за множеството на ключовете.

╟─ В .NET има две основни имплементации на интерфейса IDictionary<K, V>: Dictionary<K, V> и SortedDictionary<K, V>. SortedDictionary представлява имплементация с балансирано (червено-черно) дърво, а Dictionary – имплементация с хеш-таблица.


╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Case Insensitive
	├─┬───────────────────────────────────────────────────────────────────┘
		├─ tell the dictionary instance to use the standard string compare method (which is case sensitive) a case insensitive one. This is done using the appropriate constructor:
		
		Dictionary<string,YourClass> dic = new Dictionary<string,YourClass>(StringComparer.OrdinalIgnoreCase);
		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ SortedDictionary
	├─┬───────────────────────────────────────────────────────────────────┘

╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Print Dictionry<str, Dictionary<str, int>>
	├─┬───────────────────────────────────────────────────────────────────┘
		foreach (var user in users.OrderBy(e => e.Key))
		{
			Console.WriteLine($"{user.Key}: ");
			Console.WriteLine("{0}.", 
				string.Join(", ", user.Value.Select(
					e => $"{e.Key} => {e.Value}")));
		}

		
╟─┬─────────────────────────────────────────────────────────────────────┐
	│ Get first element
	├─┬───────────────────────────────────────────────────────────────────┘
    ├─ Note that to call First here is actually to call a Linq extension of IEnumerable, which is implemented by Dictionary<TKey,TValue>. But for a Dictionary, "first" doesn't have a defined meaning. The last item added ends up being the "First" (in other words, it behaves like a Stack), but that is implementation specific, it's not the guaranteed behavior. In other words, using it should be treated as akin to getting a random item from the Dictionary.
		
╟─├─┬───────────────────────────────────────────────────────────────────┐
    ├─ You could derive a specific meaning from the use of First by combining it with the Linq OrderBy
		├─┬─────────────────────────────────────────────────────────────────┘
      var first = dic.OrderBy(kvp => kvp.Key).First();
























─ │ ═ ║

┌ ┐ └ ┘ ┬ ┴ ├ ┤ ┼

╔ ╗ ╚ ╝ ╦ ╩ ╠ ╣ ╬

╒ ╕ ╘ ╛ ╤ ╧ ╞ ╡ ╪

╓ ╖ ╙ ╜ ╥ ╨ ╟ ╢ ╫

▀ ▄ █ ▌ ▐ ░ ▒ ▓ ■ □ ▪ ▫ ▬ ▲ ► ▼ ◄ ◊ ○ ☺ ☻
██

╔═══════════════════════════════════════════════════════════════════════╗
║
╠═══════════════════════════════════════════════════════════════════════╝
╟─
╟─┐
╟─┬─────────────────────────────────────────────────────────────────────┐
╟─┬─────────────────────────────────────────────────────────────────────┐
	│
	├─────────────────────────────────────────────────────────────────────┘
	├─
	├─┐
	├─┬───────────────────────────────────────────────────────────────────┐
	├─┬───────────────────────────────────────────────────────────────────┐
		│
		├───────────────────────────────────────────────────────────────────┘
		├─┬─────────────────────────────────────────────────────────────────┐
			├─┬───────────────────────────────────────────────────────────────┐
				│
				├───────────────────────────────────────────────────────────────┘
				├─┬─────────────────────────────────────────────────────────────┐